<!DOCTYPE html>
<html>
<head>
  <title>PortfolioAnalytics</title>
  <meta charset="utf-8">
  <meta name="description" content="PortfolioAnalytics">
  <meta name="author" content="Ross Bennett">
  <meta name="generator" content="slidify" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/default.css" media="all" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/phone.css" 
    media="only screen and (max-device-width: 480px)" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/slidify.css" >
  <link rel="stylesheet" href="libraries/highlighters/highlight.js/css/tomorrow.css" />
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->  <link rel=stylesheet href="libraries/widgets/nvd3/css/nv.d3.css"></link>
<link rel=stylesheet href="libraries/widgets/nvd3/css/rNVD3.css"></link>

  
  <!-- Grab CDN jQuery, fall back to local if offline -->
  <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.min.js"></script>
  <script>window.jQuery || document.write('<script src="libraries/widgets/quiz/js/jquery.js"><\/script>')</script> 
  <script data-main="libraries/frameworks/io2012/js/slides" 
    src="libraries/frameworks/io2012/js/require-1.0.8.min.js">
  </script>
  
  <script src="libraries/widgets/nvd3/js/jquery-1.8.2.min.js"></script>
<script src="libraries/widgets/nvd3/js/d3.v3.min.js"></script>
<script src="libraries/widgets/nvd3/js/nv.d3.min-new.js"></script>
<script src="libraries/widgets/nvd3/js/fisheye.js"></script>


</head>
<body style="opacity: 0">
  <slides class="layout-widescreen">
    
    <!-- LOGO SLIDE -->
        <slide class="title-slide segue nobackground">
  <hgroup class="auto-fadein">
    <h1>PortfolioAnalytics</h1>
    <h2>R/Finance 2015</h2>
    <p>Ross Bennett<br/></p>
  </hgroup>
  <article></article>  
</slide>
    

    <!-- SLIDES -->
    <slide class="" id="slide-1" style="background:;">
  <hgroup>
    <h2>Overview</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Discuss Portfolio Optimization</li>
<li>Introduce PortfolioAnalytics</li>
<li>Demonstrate PortfolioAnalytics with Examples</li>
</ul>

<!--
* Discuss Portfolio Optimization
    * Background and challenges of portfolio theory
* Introduce PortfolioAnalytics
    * What PortfolioAnalytics does and the problems it solves
* Demonstrate PortfolioAnalytics with Examples
    * Brief overview of the examples I will be giving
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-2" style="background:;">
  <hgroup>
    <h2>Modern Portfolio Theory</h2>
  </hgroup>
  <article data-timings="">
    <p>&quot;Modern&quot; Portfolio Theory (MPT) was introduced by Harry Markowitz in 1952.</p>

<p>In general, MPT states that an investor&#39;s objective is to maximize portfolio expected return for a given amount of risk.</p>

<p>General Objectives</p>

<ul>
<li>Maximize a measure of gain per unit measure of risk</li>
<li>Minimize a measure of risk</li>
</ul>

<p>How do we define risk? What about more complex objectives and constraints?</p>

<!--
Several approaches follow the Markowitz approach using mean return as a measure of gain and standard deviation of returns as a measure of risk. This is an academic approach. 
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-3" style="background:;">
  <hgroup>
    <h2>Portfolio Optimization Objectives</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Minimize Risk

<ul>
<li>Volatility</li>
<li>Tail Loss (VaR, ES)</li>
<li>Other Downside Risk Measure</li>
</ul></li>
<li>Maximize Risk Adjusted Return

<ul>
<li>Sharpe Ratio, Modified Sharpe Ratio</li>
<li>Several Others</li>
</ul></li>
<li>Risk Budgets

<ul>
<li>Equal Component Contribution to Risk (i.e. Risk Parity)</li>
<li>Limits on Component Contribution</li>
</ul></li>
<li>Maximize a Utility Function

<ul>
<li>Quadratic, CRRA, etc.</li>
</ul></li>
</ul>

<!--
* Expand on pros/cons of closed-form solvers vs. global solvers and what objectives can be solved.
* The challenge here is knowing what solver to use and the capabilities/limits of the chosen solver. 
* Some of these problems can be formulated as a quadratic or linear programming problem. Constructing the constraint matrix and objective function matrix or vector is not trivial. Limited to the quality of LP and QP solvers available for R. 
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-4" style="background:;">
  <hgroup>
    <h2>PortfolioAnalytics Overview</h2>
  </hgroup>
  <article data-timings="">
    <p>PortfolioAnalytics is an R package designed to provide numerical solutions and visualizations for portfolio optimization problems with complex constraints and objectives.</p>

<ul>
<li>Support for multiple constraint and objective types</li>
<li>An objective function can be any valid R function</li>
<li>Modular constraints and objectives</li>
<li>Support for user defined moment functions</li>
<li>Visualizations</li>
<li>Solver agnostic</li>
<li>Support for parallel computing</li>
</ul>

<!---
The key points to make here are:
* Flexibility
    * The multiple types and modularity of constraints and objectives allows us to add, remove, combine, etc. multiple constraint and objective types very easily.
    * Define an objective as any valid R function
    * Define a function to compute the moments (sample, robust, shrinkage, factor model, GARCH model, etc.)
    * Estimation error is a significant concern with optimization. Having the ability to test different models with different parameters is critical.
* PortfolioAnalytics comes "out of the box" with several constraint types.
* Visualization helps to build intuition about the problem and understand the feasible space of portfolios
* Periodic rebalancing and analyzing out of sample performance will help refine objectives and constraints
* Framework for evaluating portfolios with different sets of objectives and portfolios through time
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-5" style="background:;">
  <hgroup>
    <h2>New in PortfolioAnalytics</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Pushed to CRAN</li>
<li>Regime Switching Framework</li>
<li>Multilayer Optimization</li>
<li>Rank Based Optimization</li>
<li>Factor Model Moment Estimates</li>
<li>Improved Random Portfolios Algorithm</li>
<li>More demos, vignettes, and documentation</li>
</ul>

<!--
Highlight a few things about each point
* Pushed to CRAN
  * 2015-04-19
* Regime Switching Framework
  * very general framework to define 'n' portfolios for 'n' regimes
  * useful for out of sample backtesting
* Multilayer Optimization
  * more on this in next slide
* Rank Based Optimization
  * examples
* Factor Model Moment Estimates
  * statistical factor model
  * compute higher order moments based on the work of kris boudt
* Improved Random Portfolios Algorithm
  * support more constraints by construction
  * more efficient for group constraints
* More demos, vignettes, and documentation
  * added vignette for custom moments and objectives
  * demos for each new feature added last summer during GSoC 2014
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-6" style="background:;">
  <hgroup>
    <h2>Multilayer Optimization</h2>
  </hgroup>
  <article data-timings="">
    <p><img src="mult_portf.png" alt=""></p>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-7" style="background:;">
  <hgroup>
    <h2>Support Multiple Solvers</h2>
  </hgroup>
  <article data-timings="">
    <p>Linear and Quadratic Programming Solvers</p>

<ul>
<li>R Optimization Infrastructure (ROI)

<ul>
<li>GLPK (Rglpk)</li>
<li>Symphony (Rsymphony)</li>
<li>Quadprog (quadprog)</li>
</ul></li>
</ul>

<p>Global (stochastic or continuous solvers)</p>

<ul>
<li>Random Portfolios</li>
<li>Differential Evolution (DEoptim)</li>
<li>Particle Swarm Optimization (pso)</li>
<li>Generalized Simulated Annealing (GenSA)</li>
</ul>

<!---
Brief explanation of each solver and what optimization problems are supported
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-8" style="background:;">
  <hgroup>
    <h2>Random Portfolios</h2>
  </hgroup>
  <article data-timings="">
    <p>PortfolioAnalytics has three methods to generate random portfolios.</p>

<ol>
<li>The <strong>sample</strong> method to generate random portfolios is based on an idea by Pat Burns.</li>
<li>The <strong>simplex</strong> method to generate random portfolios is based on a paper by W. T. Shaw.</li>
<li>The <strong>grid</strong> method to generate random portfolios is based on the <code>gridSearch</code> function in the NMOF package.</li>
</ol>

<!--
* Random portfolios allow one to generate an arbitray number of portfolios based on given constraints. Will cover the edges as well as evenly cover the interior of the feasible space. Allows for massively parallel execution.

* The sample method to generate random portfolios is based on an idea by Patrick Burns. This is the most flexible method, but also the slowest, and can generate portfolios to satisfy leverage, box, group, and position limit constraints.

* The simplex method to generate random portfolios is based on a paper by W. T. Shaw. The simplex method is useful to generate random portfolios with the full investment constraint, where the sum of the weights is equal to 1, and min box constraints. Values for min_sum and max_sum of the leverage constraint will be ignored, the sum of weights will equal 1. All other constraints such as the box constraint max, group and position limit constraints will be handled by elimination. If the constraints are very restrictive, this may result in very few feasible portfolios remaining. Another key point to note is that the solution may not be along the vertexes depending on the objective. For example, a risk budget objective will likely place the portfolio somewhere on the interior.

* The grid method to generate random portfolios is based on the gridSearch function in NMOF package. The grid search method only satisfies the min and max box constraints. The min_sum and max_sum leverage constraint will likely be violated and the weights in the random portfolios should be normalized. Normalization may cause the box constraints to be violated and will be penalized in constrained_objective.
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-9" style="background:;">
  <hgroup>
    <h2>Comparison of Random Portfolio Methods (Interactive!)</h2>
  </hgroup>
  <article data-timings="">
    <p>RP</p>

<!--

```
Warning: cannot open compressed file 'figures/rp_viz.rda', probable reason
'No such file or directory'
```

```
Error: cannot open the connection
```

```
Error: object 'rp_viz' not found
```

The feasible space is computed using the EDHEC data for a long only portfolio with a search size of 2000.
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-10" style="background:;">
  <hgroup>
    <h2>Random Portfolios: Simplex Method</h2>
  </hgroup>
  <article data-timings="">
    <p>RP Simplex</p>

<!--
FEV (Face-Edge-Vertex bias values control how concentrated a portfolio is. This can clearly be seen in the plot. As FEV approaches infinity, the portfolio weight will be concentrated on a single asset. PortfolioAnalytics allows you to specify a vector of fev values for comprehensive coverage of the feasible space. 
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-11" style="background:;">
  <hgroup>
    <h2>Workflow: Specify Portfolio</h2>
  </hgroup>
  <article data-timings="">
    <pre><code class="r">args(portfolio.spec)
</code></pre>

<pre><code>## function (assets = NULL, category_labels = NULL, weight_seq = NULL, 
##     message = FALSE) 
## NULL
</code></pre>

<p>Initializes the portfolio object that holds portfolio level data, constraints, and objectives</p>

<!--
The portfolio object is an S3 object that holds portfolio-level data, constraints, and objectives. The portfolio-level data includes asset names and initial weights, labels to categorize assets, and a sequence of weights for random portfolios. The main argument is assets which can be a character vector (most common use), named numeric vector, or scalar value specifying number of assets.
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-12" style="background:;">
  <hgroup>
    <h2>Workflow: Add Constraints</h2>
  </hgroup>
  <article data-timings="">
    <pre><code class="r">args(add.constraint)
</code></pre>

<pre><code>## function (portfolio, type, enabled = TRUE, message = FALSE, ..., 
##     indexnum = NULL) 
## NULL
</code></pre>

<p>Supported Constraint Types</p>

<ul>
<li>Sum of Weights</li>
<li>Box</li>
<li>Group</li>
<li>Factor Exposure</li>
<li>Position Limit</li>
<li>and many more</li>
</ul>

<!--
This adds a constraint object to the portfolio object. Constraints are added to the portfolio object with the add.constraint function. Each constraint added is a separate object and stored in the constraints slot in the portfolio object. In this way, the constraints are modular and one can easily add, remove, or modify the constraints in the portfolio object. Main argument is the type, arguments to the constraint constructor are then passed through the dots (...).
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-13" style="background:;">
  <hgroup>
    <h2>Workflow: Add Objectives</h2>
  </hgroup>
  <article data-timings="">
    <pre><code class="r">args(add.objective)
</code></pre>

<pre><code>## function (portfolio, constraints = NULL, type, name, arguments = NULL, 
##     enabled = TRUE, ..., indexnum = NULL) 
## NULL
</code></pre>

<p>Supported Objective types</p>

<ul>
<li>Return</li>
<li>Risk</li>
<li>Risk Budget</li>
<li>Weight Concentration</li>
</ul>

<!--
Objectives are added to the portfolio object with the add.objective function. Each objective added is a separate object and stored in the objectives slot in the portfolio object. In this way, the objectives are modular and one can easily add, remove, or modify the objective objects. The name argument must be a valid R function. Several functions are available in the PerformanceAnalytics package, but custom user defined functions can be used as objective functions.
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-14" style="background:;">
  <hgroup>
    <h2>Workflow: Run Optimization</h2>
  </hgroup>
  <article data-timings="">
    <pre><code class="r">args(optimize.portfolio)
</code></pre>

<pre><code>## function (R, portfolio = NULL, constraints = NULL, objectives = NULL, 
##     optimize_method = c(&quot;DEoptim&quot;, &quot;random&quot;, &quot;ROI&quot;, &quot;pso&quot;, &quot;GenSA&quot;), 
##     search_size = 20000, trace = FALSE, ..., rp = NULL, momentFUN = &quot;set.portfolio.moments&quot;, 
##     message = FALSE) 
## NULL
</code></pre>

<pre><code class="r">args(optimize.portfolio.rebalancing)
</code></pre>

<pre><code>## function (R, portfolio = NULL, constraints = NULL, objectives = NULL, 
##     optimize_method = c(&quot;DEoptim&quot;, &quot;random&quot;, &quot;ROI&quot;), search_size = 20000, 
##     trace = FALSE, ..., rp = NULL, rebalance_on = NULL, training_period = NULL, 
##     rolling_window = NULL) 
## NULL
</code></pre>

<!--
* Notice the similarity between these two functions. You only have to specify a few additional arguments for the backtesting.

* optimize.portfolio: Main arguments for a single period optimization are the returns (R), portfolio, and optimize_method. We take the portfolio object and parse the constraints and objectives according to the optimization method.

* optimize.portfolio.rebalancing: Supports periodic rebalancing (backtesting) to examine out of sample performance. Helps refine constraints and objectives by analyzing out or sample performance. Essentially a wrapper around optimize.portfolio that handles the time interface.
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-15" style="background:;">
  <hgroup>
    <h2>Workflow: Analyze Results</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Visualization</th>
<th>Data Extraction</th>
</tr>
</thead><tbody>
<tr>
<td>plot</td>
<td>extractObjectiveMeasures</td>
</tr>
<tr>
<td>chart.Concentration</td>
<td>extractStats</td>
</tr>
<tr>
<td>chart.EfficientFrontier</td>
<td>extractWeights</td>
</tr>
<tr>
<td>chart.RiskReward</td>
<td>print</td>
</tr>
<tr>
<td>chart.RiskBudget</td>
<td>summary</td>
</tr>
<tr>
<td>chart.Weights</td>
<td></td>
</tr>
</tbody></table>

<!--
Brief explanation of each function.
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-16" style="background:;">
  <hgroup>
    <h2>Portfolio Optimization</h2>
  </hgroup>
  <article data-timings="">
    <p><img src="opt_fig.png" alt=""></p>

<!--

High level portfolio optimization framework

Inputs
  * Assets
  * Constraints
  * Objectives
  * Moments of asset returns

The assets, constraints, and objectives are defined by the portfolio manager.
In general, these are fixed and there is no estimation or uncertainty. However,
the moments of the asset returns must be estimated. The objectives defined in
the portfolio optimization problem determine which moments and comoments must
be estimated. Moments of the asset returns are key inputs to the optimization.

Beware! Optimizers are error maximizers
Bad Estimates  Bad Results
Better Estimates  Better Results
GIGO (Garbage In Garbage Out)

Mean - Variance
  * expected returns
  * covariance matrix

Minimum Variance
  * covariance matrix

Mean - Expected Shortfall (mean - ES)
  * expected returns vector
  * covariance matrix
  * coskewness matrix
  * cokurtosis matrix
  
If the returns are normally distributed, one can use the analytical formula for
ES which only requires estimates of the first and second moments.

The modified ES (based on Cornish-Fisher expansions) has been shown to deliver
accurate estimates for portfolios with nonnormal returns

For modified ES, one must estimate of the first four moments of the asset 
returns.

Minimum Expected Shortfall
  * expected returns vector
  * covariance matrix
  * coskewness matrix
  * cokurtosis matrix

Same comments as above apply here. The moments to estimate depend on the choice
of the risk measure, e.g. ES vs. modified ES.

Expected Utility
Here the moments to estimate are highly dependent on the choice of utility
function. 

Quadratic Utility
  * expected returns vector
  * covariance matrix

Fourth order expansion of the Constant Relative Risk Aversion (CRRA) Utility Function
Martellini and Ziemann (2010) and Boudt et al (2014)
  * expected returns vector (assume zero mean and omit)
  * covariance matrix
  * coskewness matrix
  * cokurtosis matrix

-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-17" style="background:;">
  <hgroup>
    <h2>Estimating Moments</h2>
  </hgroup>
  <article data-timings="">
    <p>Ledoit and Wolf (2003):</p>

<blockquote>
<p>&quot;The central message of this paper is that nobody should be using the sample
covariance matrix for the purpose of portfolio optimization.&quot;</p>
</blockquote>

<ul>
<li>Sample</li>
<li>Shrinkage Estimators</li>
<li>Factor Model</li>
<li>Expressing Views</li>
</ul>

<!--
From Ledoit and Wolf (2003), "Honey, I Shrunk the Sample Covariance Matrix"
The central message of this paper is that nobody should be using the sample 
covariance matrix for the purpose of portfolio optimization.

Estimating moments using shrinkage estimators, factor models, views are methods
to address the disadvantages of using sample estimates. I am not making a claim
that one method is better than another. The method chosen depends on one's own
situation and information/data available.

Increase risk of estimation error as dimension of assets and parameters to
estimate increase

Sample Estimates Disadvantages
  * Estimation error and the curse of dimensionality
  * In the Mean - Variance framework, small changes in expected returns can 
  lead to extreme portfolios (large long/short positions) in the unconstrained
  case and concentrated (large positions in few assets) portfolios wth long
  only constraint.
  * Note that adding constraints have of the effect of lessening the impact of 
  estimation error. TODO: reference? I remember Doug stating this

The estimation of a covariance matrix is unstable unless the number of
historical observations T is greater than the number of assets N. 
10 years of data
daily: 2500
weekly: 520
monthly: 120

One has the choice to estimate moments with historical or simulated data.

Historical Data
  * do you have enough data?
  * missing assets
  * is it clean?

Simulated data
  * Model risk
  * How well does the model describe the data?

* Shrinkage Estimators
  * Ledoit-Wolf
  * James-Stein
* Factor Model
  * Fundamental
  * Statistical
  * Boudt et al (2014) use factor model to estimate higher order comoments
* Expressing Views
  * Black - Litterman
  * Almgren and Chriss, Portfolios from Sorts
  * Meucci, Fully Flexible Views Framework
* Other
  * Resampling
  * ?

-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-18" style="background:;">
  <hgroup>
    <h2>Meucci Fully Flexible Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>Reference Model
\[ X \sim f_X \]</p></li>
<li><p>Views
\[ V \equiv g (X) \sim f_V \]</p></li>
<li><p>Express View on Ranking
\[ m \{ V_1 \} \geq  m \{ V_2 \} \geq ... \geq  m \{ V_K \} \]</p></li>
<li><p>Posterior
\[ \tilde{f}_x \equiv \underset{f \in V}{\text{ argmin    }} { entropy(f, f_x) } \]</p></li>
</ul>

<!--

Key difference between BL and FFV
The Black-Litterman approach allows the portfolio manager to express views
on the expected returns vector. The model quantifies views and uncertainty
of views.

The Meucci FFV framework is more general and allows one to express views on the
market. 

From Meucci paper
http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1213325

To obtain the posterior, we interpret the views as statements that distort the
prior distribution, in such a way that the least possible amount of spurious
structure is imposed. The natural index for the structure of a distribution is
its entropy. Therefore we define the posterior distribution as the one that
minimizes the entropy relative to the prior. Then by opinion pooling we assign
different confidence levels to different views and users.

Reference Model
We assume the existence of a risk model, i.e. a model for the joint
distribution of the risk factors, as represented by its probability density
function (pdf)
X \dist f\_X

Views
In the most general case, the user expresses views on generic functions of the
market g1 (X) , . . . , gK (X). These functions constitute a K -dimensional
random variable whose joint distribution is implied by the reference model
V = g (X) \dist f\_V

views in general are statements on only select features of the distribution of V
The generalized BL views are not necessarily expressed as equality constraint:
EP can process views expressed as inequalities. In particular, EP can process
ordering information, frequent in stock and bond management:

m { V\_1 } >=  m { V\_2 } >= ... >= m { V\_K }

The posterior
The posterior distribution should satisfy the views without adding additional
structure and should be as close as possible to the reference model

The posterior market distribution is the one that minimizes the relative
entropy

perform entropy minimization to obtain posterior

perform entropy minimization between a distribution f and the reference model f_x
\tilde{f}\_x = argmin{ entropy(f, f\_x) } f \in V stands for all the 
distributions consistent with the views statement

Confidence
Opinion Pooling
\tilde{f}\_x^c = (1 - c) * f\_x + c * \tilde{f}\_x
pooling parameter c in [0,1] represents the confidence levels in the views
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-19" style="background:;">
  <hgroup>
    <h2>Almgren-Chriss Portfolios from Sorts</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>Define $ S_1, ... , S_n $ as the investment universe of $ n $ assets</p></li>
<li><p>Defining Sorts</p>

<ul>
<li>Single complete sort
\[ r_1 \geq r_2 \geq ... \geq r_n \]</li>
<li>Sector based sort</li>
<li>Deciles and Other Divisions</li>
<li>Single complete sort with longs and shorts</li>
<li>others</li>
</ul></li>
<li><p>Centroid vector, $ c $, is defined as the center of mass of the set $ Q $.</p>

<ul>
<li>where $ Q $ is the space of consistent expected returns</li>
</ul></li>
</ul>

<!--

The Black-Litterman approach allows the portfolio manager to express views
on the expected returns vector. The model quantifies views and uncertainty
of views.

Portfolios from Sorts is a method for portfolio optimization based on replacing
expected returns with information about the order of the expected returns.
For a single complete sort we assume that each expected return direction is
equally likely: there is no bias toward some directions over others. The only
information in the model is the sort itself.

From the paper
We shall write S1, . . . , Sn for the available investment universe of n stocks.
In its most general sense, a portfolio sort is a set of inequality relationships
between the expected returns of these assets. The simplest and most common
example is a single complete sort which orders all the assets of the portfolio
by expected return from greatest to least.

r\_1 >= r\_2 >= ... >= r\_n

A sort is a set of beliefs about the first moments of the joint distribution of
returns

If we have a portfolio of stocks S1,...,Sn ordered so that r1 >= ··· >= rn then
we are positing two things. First, the obvious, that the expected returns of the
stocks, or more precisely, the joint distribution of the stocks, respect the
ordering. Second, this information is the only information we have about the
expected returns.

the information in an expected return vector relevant for optimization is
contained completely in its vector direction, not in its magnitude.

centroid vector
analytical approximation for a single complete sort
monte carlo estimate for other estimates
  * sector
  * sign
  * buckets

-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-20" style="background:;">
  <hgroup>
    <h2>Example</h2>
  </hgroup>
  <article data-timings="">
    <pre><code class="r"># Load package and data.
library(PortfolioAnalytics)
data(edhec)
R &lt;- edhec[,1:4]
funds &lt;- colnames(R)

# Construct initial portfolio with basic constraints.
init.portf &lt;- portfolio.spec(assets=funds)
init.portf &lt;- add.constraint(portfolio=init.portf, type=&quot;weight_sum&quot;, 
                             min_sum=0.99, max_sum=1.01)
init.portf &lt;- add.constraint(portfolio=init.portf, type=&quot;box&quot;,
                             min=0.05, max=0.5)
init.portf &lt;- add.objective(portfolio=init.portf, type=&quot;risk&quot;, name=&quot;StdDev&quot;)
init.portf &lt;- add.objective(portfolio=init.portf, type=&quot;return&quot;, name=&quot;mean&quot;)

# Generate random portfolios for use in the optimization.
rp &lt;- random_portfolios(init.portf, 5000)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-21" style="background:;">
  <hgroup>
    <h2>Example</h2>
  </hgroup>
  <article data-timings="">
    <pre><code class="r"># Here we express views on the relative rank of the asset returns
# E{ R[,2] &lt; R[,3] &lt; R[,1] &lt; R[,4] }
asset.rank &lt;- c(2, 3, 1, 4)
</code></pre>

<h3>Meucci: Fully Flexible Views Framework</h3>

<pre><code class="r">p &lt;- rep(1 / nrow(R), nrow(R))
m.moments &lt;- meucci.ranking(R, p, asset.rank)
</code></pre>

<h3>Almgren and Chriss: Portfolios from Sorts</h3>

<pre><code class="r">ac.moments &lt;- list()
ac.moments$mu &lt;- ac.ranking(R, asset.rank)
# Sample estimate for second moment
ac.moments$sigma &lt;- cov(R)
</code></pre>

<!--
meucci.ranking does the entropy minimization and computes the first and second
moments given the market data and posterior probability.

EntropyProg does the entropy minimization and returns the posterior probabilities

meucci.moments computes the first and second moments given the market data and
posterior probability

ac.ranking computes the estimated centroid vector from a single complete sort
using the analytical approximation as described in R. Almgren and N. Chriss,
"Portfolios from Sorts". The centroid is estimated and then scaled such that it
is on a scale similar to the asset returns. By default, the centroid vector is
scaled according to the median of the asset mean returns.

-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-22" style="background:;">
  <hgroup>
    <h2>Example Optimization</h2>
  </hgroup>
  <article data-timings="">
    <pre><code class="r"># Use moments output from meucci.ranking
opt.meucci &lt;- optimize.portfolio(R, 
                                 init.portf, 
                                 optimize_method=&quot;random&quot;, 
                                 rp=rp, 
                                 trace=TRUE,
                                 momentargs=m.moments)

# Use first moment from ac.ranking. Note second moment is sample covariance
opt.ac &lt;- optimize.portfolio(R, 
                             init.portf, 
                             optimize_method=&quot;random&quot;, 
                             rp=rp, 
                             trace=TRUE,
                             momentargs=ac.moments)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-23" style="background:;">
  <hgroup>
    <h2>Optimization Results</h2>
  </hgroup>
  <article data-timings="">
    <p>TODO: Insert image for optimal weights</p>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-24" style="background:;">
  <hgroup>
    <h2>Custom Moment Function</h2>
  </hgroup>
  <article data-timings="">
    <pre><code class="r">moment.ranking &lt;- function(R, n=1, method=c(&quot;meucci&quot;, &quot;ac&quot;)){
  method &lt;- match.arg(method)
  tmpR &lt;- apply(tail(R, n), 2, function(x) prod(1 + x) - 1)
  # Assume that the assets with the highest return will continue to outperform
  asset.rank &lt;- order(tmpR)
  switch(method,
         meucci = {
           p &lt;- rep(1 / nrow(R), nrow(R))
           moments &lt;- meucci.ranking(R, p, asset.rank)
         },
         ac = {
           moments &lt;- list()
           moments$mu &lt;- ac.ranking(R, asset.rank)
           moments$sigma &lt;- cov(R)
         })
  moments
}
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-25" style="background:;">
  <hgroup>
    <h2>Optimization with Periodic Rebalancing</h2>
  </hgroup>
  <article data-timings="">
    <pre><code class="r">opt.bt.meucci &lt;- optimize.portfolio.rebalancing(R, init.portf, 
                                                optimize_method=&quot;random&quot;, 
                                                rebalance_on=&quot;quarters&quot;, 
                                                training_period=100,
                                                rp=rp,
                                                momentFUN=&quot;moment.ranking&quot;,
                                                n=3,
                                                method=&quot;meucci&quot;)

opt.bt.ac &lt;- optimize.portfolio.rebalancing(R, init.portf, 
                                            optimize_method=&quot;random&quot;, 
                                            rebalance_on=&quot;quarters&quot;, 
                                            training_period=100,
                                            rp=rp,
                                            momentFUN=&quot;moment.ranking&quot;,
                                            n=3,
                                            method=&quot;ac&quot;)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-26" style="background:;">
  <hgroup>
    <h2>Optimization Results</h2>
  </hgroup>
  <article data-timings="">
    <p>TODO: Insert performance summary chart and table of annualized returns</p>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-27" style="background:;">
  <hgroup>
    <h2>Conclusion</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Introduced the goals and summary of PortfolioAnalytics</li>
<li>Demonstrated the flexibility through examples</li>
<li>Plans for continued development

<ul>
<li>Interface to \(parma\)</li>
<li>Additional solvers</li>
<li>&quot;Gallery&quot; of examples</li>
</ul></li>
</ul>

<h4>Acknowledgements</h4>

<p>Many thanks to...</p>

<ul>
<li>Google: funding Google Summer of Code (GSoC) for 2014 and 2015</li>
<li>UW CF&amp;RM Program: continued work on PortfolioAnalytics</li>
<li>GSoC Mentors: Brian Peterson, Peter Carl, Doug Martin, and Guy Yollin</li>
<li>R/Finance Committee</li>
</ul>

<!---
- One of the best things about GSoC is the opportunity to work and interact with the mentors.
- Thank the GSoC mentors for offering help and guidance during the GSoC project and after as I continued to work on the PortfolioAnalytics package.
- R/Finance Committee for the conference and the opportunity to talk about PortfolioAnalytics.
- Google for funding the Google Summer of Code for PortfolioAnalytics and many other proposals for R

Thank everyone for attending
I hope they learned something and are motivated to use PortfolioAnalytics
-->

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-28" style="background:;">
  <hgroup>
    <h2>PortfolioAnalytics Links</h2>
  </hgroup>
  <article data-timings="">
    <p>PortfolioAnalytics on CRAN</p>

<ul>
<li><a href="http://cran.at.r-project.org/web/packages/PortfolioAnalytics/index.html">PortfolioAnalytics</a></li>
</ul>

<p>PortfolioAnalytics development on R-Forge in the ReturnAnalytics project</p>

<ul>
<li><a href="https://r-forge.r-project.org/projects/returnanalytics/">PortfolioAnalytics</a></li>
</ul>

<p>Source code for the slides</p>

<ul>
<li><a href="https://github.com/rossb34/PortfolioAnalyticsPresentation2015">https://github.com/rossb34/PortfolioAnalyticsPresentation2015</a></li>
</ul>

<p>and view it here</p>

<ul>
<li><a href="http://rossb34.github.io/PortfolioAnalyticsPresentation2015/">http://rossb34.github.io/PortfolioAnalyticsPresentation2015/</a></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-29" style="background:;">
  <hgroup>
    <h2>Any Questions?</h2>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-30" style="background:;">
  <hgroup>
    <h2>References and Useful Links</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><a href="http://cran.r-project.org/web/packages/ROI/index.html">ROI</a></li>
<li><a href="http://cran.r-project.org/web/packages/DEoptim/index.html">DEoptim</a></li>
<li><a href="http://cran.r-project.org/web/packages/pso/index.html">pso</a></li>
<li><a href="http://cran.r-project.org/web/packages/GenSA/index.html">GenSA</a></li>
<li><a href="http://cran.r-project.org/web/packages/PerformanceAnalytics/index.html">PerformanceAnalytics</a></li>
<li><a href="http://www.burns-stat.com/pages/Finance/randport_practice_theory_annotated.pdf">Patrick Burns Random Portfolios</a></li>
<li><a href="http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1856476">W.T. Shaw Random Portfolios</a></li>
<li>Martellini paper</li>
<li>Boudt paper</li>
<li><a href="http://spark.rstudio.com/rossbennett3/PortfolioOptimization/">Shiny App</a></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

    <slide class="backdrop"></slide>
  </slides>
  <div class="pagination pagination-small" id='io2012-ptoc' style="display:none;">
    <ul>
      <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=1 title='Overview'>
         1
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=2 title='Modern Portfolio Theory'>
         2
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=3 title='Portfolio Optimization Objectives'>
         3
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=4 title='PortfolioAnalytics Overview'>
         4
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=5 title='New in PortfolioAnalytics'>
         5
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=6 title='Multilayer Optimization'>
         6
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=7 title='Support Multiple Solvers'>
         7
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=8 title='Random Portfolios'>
         8
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=9 title='Comparison of Random Portfolio Methods (Interactive!)'>
         9
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=10 title='Random Portfolios: Simplex Method'>
         10
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=11 title='Workflow: Specify Portfolio'>
         11
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=12 title='Workflow: Add Constraints'>
         12
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=13 title='Workflow: Add Objectives'>
         13
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=14 title='Workflow: Run Optimization'>
         14
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=15 title='Workflow: Analyze Results'>
         15
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=16 title='Portfolio Optimization'>
         16
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=17 title='Estimating Moments'>
         17
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=18 title='Meucci Fully Flexible Views'>
         18
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=19 title='Almgren-Chriss Portfolios from Sorts'>
         19
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=20 title='Example'>
         20
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=21 title='Example'>
         21
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=22 title='Example Optimization'>
         22
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=23 title='Optimization Results'>
         23
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=24 title='Custom Moment Function'>
         24
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=25 title='Optimization with Periodic Rebalancing'>
         25
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=26 title='Optimization Results'>
         26
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=27 title='Conclusion'>
         27
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=28 title='PortfolioAnalytics Links'>
         28
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=29 title='Any Questions?'>
         29
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=30 title='References and Useful Links'>
         30
      </a>
    </li>
  </ul>
  </div>  <!--[if IE]>
    <script 
      src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js">  
    </script>
    <script>CFInstall.check({mode: 'overlay'});</script>
  <![endif]-->
</body>
  <!-- Load Javascripts for Widgets -->
  
  <!-- MathJax: Fall back to local if CDN offline but local image fonts are not supported (saves >100MB) -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- <script src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script> -->
  <script>window.MathJax || document.write('<script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS":{imageFont:null}});<\/script><script src="libraries/widgets/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"><\/script>')
</script>
<!-- LOAD HIGHLIGHTER JS FILES -->
  <script src="libraries/highlighters/highlight.js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <!-- DONE LOADING HIGHLIGHTER JS FILES -->
   
  </html>